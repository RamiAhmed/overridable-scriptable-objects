using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerator;

[Generator]
public class SerializableObjectGenerator : IIncrementalGenerator
{
    private const string InterfaceName = "IOverridableScriptableObject";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(IsNotStaticAbstractOrInterface, TransformNode)
            .Where(c => c is not null);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right!));
    }

    private static bool IsNotStaticAbstractOrInterface(SyntaxNode node, CancellationToken _)
    {
        return node is TypeDeclarationSyntax typeDeclarationSyntax
               && typeDeclarationSyntax.Modifiers.All(m =>
                   !m.IsKind(SyntaxKind.AbstractKeyword)
                   && !m.IsKind(SyntaxKind.StaticKeyword)
                   && !m.IsKind(SyntaxKind.InterfaceKeyword));
    }

    private static TypeDeclarationSyntax? TransformNode(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Check if the class or struct implements the interface
        var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration, cancellationToken);
        if (typeSymbol == null
            || !InheritsFrom(typeSymbol, "OverridableScriptableObject"))
            return null;

        return typeDeclaration;
    }

    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<TypeDeclarationSyntax> typeDeclarations)
    {
        foreach (var typeDeclaration in typeDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(typeDeclaration) is not { } typeSymbol)
                continue;

            var fields = GetAllFields(typeSymbol).ToImmutableArray();
            if (fields == null || !fields.Any())
                continue;

            var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
            var typeName = typeDeclaration.Identifier.Text;

            var namespaceUsings = fields
                .Select(p => p.Type.ContainingNamespace)
                .Where(n => n is not null)
                .Select(n => n.ToDisplayString())
                .Where(n => n != namespaceName)
                .Concat(["System", "OverridableScriptableObjects.Runtime"])
                .Distinct()
                .OrderBy(n => n)
                .Select(n => $"using {n};");

            var code = $$"""
                         // <auto-generated/>
                         // Generated by SerializableObjectGenerator at {{DateTime.Now:yyyy-MM-dd HH:mm:ss}}.
                         // Do NOT edit this file manually, as any changes will be lost when the source generator runs again.

                         {{string.Join("\n", namespaceUsings)}}

                         namespace {{namespaceName}}
                         {
                             /// <summary>
                             /// This class is auto-generated by SerializableObjectGenerator as a serializable representation of the <see cref="{{typeName}}"/> class.
                             /// It contains fields for each public instance field of the class.
                             /// </summary>
                             [System.Serializable]
                             public class {{typeName}}_GeneratedSerializableData : ISerializableOverridableScriptableObject
                             {
                                 // Fields
                                 {{string.Join("\n\t\t", fields.Select(p => $"public {p.Type.ToDisplayString()} {p.Name};"))}}
                                 
                                 /// <inheritdoc />
                                 public void ApplyTo(OverridableScriptableObject target)
                                 {
                                     if (target == null) 
                                        throw new ArgumentNullException(nameof(target));

                                     // Apply fields to the target object
                                     var t = ({{typeName}})target;
                                     {{string.Join("\n\t\t\t", fields.Select(p => $"t.{p.Name} = {p.Name};"))}}
                                 }
                                 
                                 /// <inheritdoc />
                                 public void CopyFrom(OverridableScriptableObject source)
                                 {
                                     if (source == null) 
                                        throw new ArgumentNullException(nameof(source));

                                     // Copy fields from the source object
                                     var s = ({{typeName}})source;
                                     {{string.Join("\n\t\t\t", fields.Select(p => $"{p.Name} = s.{p.Name};"))}}
                                 }
                             }
                         }

                         """;

            // Add the generated code to the compilation
            context.AddSource($"{typeName}.GeneratedSerializableData.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }


    private static IEnumerable<IFieldSymbol> GetAllFields(ITypeSymbol typeSymbol)
    {
        var currentType = typeSymbol;
        while (currentType != null && currentType.SpecialType != SpecialType.System_Object)
        {
            var members = currentType
                .GetMembers()
                .OfType<IFieldSymbol>()
                .Where(t => t is { IsStatic: false, IsConst: false, IsReadOnly: false })
                .Where(t => t.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal)
                .Where(t => !IsUnityEngineObject(t.Type));

            foreach (var member in members)
                yield return member;

            currentType = currentType.BaseType;

            // Stop if we reach ScriptableObject, as we don't want to include its properties.
            if (currentType?.Name == "ScriptableObject")
                break;
        }
    }

    private static bool InheritsFrom(ITypeSymbol typeSymbol, string baseTypeName)
    {
        var current = typeSymbol.BaseType;
        while (current != null && current.SpecialType != SpecialType.System_Object)
        {
            if (current.Name == baseTypeName)
                return true;

            current = current.BaseType;

            if (current?.Name == "ScriptableObject")
                break; // Stop if we reach ScriptableObject, as we don't want to include its properties.
        }

        return false;
    }

    private static bool IsUnityEngineObject(ITypeSymbol typeSymbol)
    {
        var current = typeSymbol;
        while (current != null && current.SpecialType != SpecialType.System_Object)
        {
            if (current.Name == "Object" && current.ContainingNamespace.ToDisplayString() == "UnityEngine")
                return true;
            
            current = current.BaseType;
        }

        return false;
    }
}